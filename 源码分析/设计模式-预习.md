## 1. 回顾以下我所听过或者用过的设计模式
1. 单例模式-Singleton
    - 懒汉模式
    - 饿汉模式
2. 工厂模式-Factory
3. 代理模式-Proxy
    - 动态代理模式
        - AOP
    - 静态代理模式
4. 模板模式-Template
    - RedisTemplate
    - TransactionTemplate
5. 装饰器模式-Decorator
6. 原型模式-Propotype

## 2. 看一下授课文档中的设计模式
#### 将设计模式分为三种主要类型：
1. 创建型
    - 工厂方法模式-Factory Method
    - 抽象工厂模式-Abstract Factory
    - 建造者模式-Builder
    - 单例模式-Singleton
    - 原型模式-Prototype
2. 结构型
    - 代理模式-Proxy
    - 装饰器模式-Decorator
    - 门面模式-Facade
    - 适配器模式-Adapter
    - 桥接模式-Bridge
    - 组合模式-Composite
    - 享元模式-Flyweight
3. 行为型
    - 模板方法-Template
    - 解释器模式-Interpreter
    - 责任链模式-Chain of Responsebility
    - 命令模式-Command
    - 迭代器模式-Iterator
    - 调节器模式-Mediator
    - 备忘录模式-Memento
    - 观察者模式-Observer
    - 状态模式-State
    - 策略模式-Strategy
    - 访问者模式-Visitor
> 问题1: 由于对大部分的设计模式的不熟悉，我并不知道结构型和行为型的设计模式的区别。创建型倒是蛮清楚的，创建型的设计模式是为了更好的管理实例的创建。 

#### 设计模式在应用中的六大原则
1. 开闭原则（open close principle）
    - 对扩展开发，对修改关闭
    - 在程序需要进行拓展的时候，不能去修改原有的代码。

        > 我的不恰当的理解：比如说APP接口，需要向下兼容，不能修改原有的代码，而是拓展出来。

    - 目的：易于扩展和维护
    - 如何达到这个目的？抽象化。使用接口和抽象类。
2. 里氏代换原则（Lickov Substitution Principle）
    - 内容：任何基类可以出现的地方，子类一定可以出现。

    > 有什么用呢？这里所说的出现指的是什么意思？
3. 依赖倒转原则（Dependence Inversion Principle）
    - 针对接口编程

    > 这个好理解。依赖于抽象的接口写具体的实现。而不是依赖于具体。

4. 接口隔离原则（Interface Segregation Principle）
    - 使用多个隔离的接口比使用一个接口要好。
    - 所有的一切都是为了降低依赖、降低耦合。
5. 迪米特法则（最少知道原则）（Demiter Principle）

    - 一个实体和另一个实体之间的关联越少越好。使得模块之间相对独立。
6. 合成复用原则（Composize Reuse Principle）

    - 尽量使用合成/聚合的方式而不是继承。

> 都是些什么鬼原则，单看名字完全看不懂。        
> 我的理解：        
> 1. 开闭原则是以抽象化的方式实现易扩展易维护的目的。   
> 2. 里氏代换原则说的是开闭原则的具体实现规则。     
>   说了这么六大原则，终极目标就是降低耦合。


## 3. 我为什么要学习设计模式
1. 学习设计模式能够让我在阅读源码时候，能够更好了理解设计者为什么这么设计。能够让我们知道设计者在什么样的情况下使用了什么设计模式。如果我来设计，可不可以使用其他的方式或者模式会达到一个更好的效果。
2. 源码里面有很多设计模式。是我们的内功。

## 4. 各个设计模式的优缺点

## 讲师简历


