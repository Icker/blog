---
title: 二、数据结构之栈和队列
tags: 数据结构
categories: 数据结构
---



栈和队列是两种特殊的线性表。

- 栈：先进后出；
- 队列：先进先出。



# 栈（Stack）

栈是限制只能在栈顶进行插入、删除操作的线性表。先进后出（LIFO-last in first out）。

![](https://blog.airaccoon.cn/img/bed/20200102/1577960534167.png)

1. push：进栈。插入数据到栈顶。新插入的都是最新的元素。最早插入的数据在栈底（栈底元素）。
2. pop：退栈。弹出数据，会被删除。每次删除的数据都是最新的元素（栈顶元素）
3. peek：观看一下最新元素，不做删除。每次看的都是最新的元素（栈顶元素）



## 顺序栈

顺序栈是顺序表的简化版本，只能对栈顶操作。唯一重要的是确定栈顶是数组的哪头。

假设n个元素，以游标0作为栈顶，那么每压入或者弹出一个元素，就要移动每一个元素，时间复杂度是$$ O(n) $$；

假设还是n个元素，以游标n-1作为栈顶，那么每压入或者弹出一个元素，就不需要移动任何元素，只是单纯操作需要处理的元素，时间复杂度就是$$ O(1) $$。

这里我们就需要避免**上溢**。

在Java中的`Stack`类实现了顺序栈，并且是默认容量为10的数组，当检测到入栈数量大于10时，就会复制一个新的数组，容量是上一次容量的两倍，否则继续压栈就会发生上溢问题。

![](https://blog.airaccoon.cn/img/bed/20200104/1578117545753.png)



![](https://blog.airaccoon.cn/img/bed/20200104/1578117690251.png)



## 链式栈

是链表的简化版本。只针对表头操作。

相对于顺序栈，两者的时间复杂度都是常数时间$$ O(1) $$。链式栈不需要考虑上溢的问题，但需要增加指针的空间开销。



## 应用场景

### 递归

递归和栈都是先进后出。一般的递归方式在时间和空间上是不节省的。我们能够通过栈来实现递归程序的非递归实现。



## 时间复杂度

| 时间复杂度 | 顺序栈     | 链式栈     |
| ---------- | ---------- | ---------- |
| 插入       | $$ O(1) $$ | $$ O(1) $$ |
| 删除       | $$ O(1) $$ | $$ O(1) $$ |



# 队列（Queue）

先入先出。队列的操作在两端进行，队首删除，队尾插入。FIFO（First In First Out）

![](https://blog.airaccoon.cn/img/bed/20200103/1578037705859.png)

按照存储结构不同，队列分为顺序队列和链式队列。



## 顺序队列

顺序队列其实就是操作受限的顺序表。

顺序队列和栈一样也存在上溢现象。同时，队列还会存在**假溢出**现象。所谓假溢出就是在入队和出队操作中，头尾指针不断增加但不减少，或则只减少不增加，导致被删除元素的空间无法重新利用，造成队列有大量空余空间不能插入新的元素或者删除元素。最终当尾指针到达数组上界之后，据不能进行入队或者出对操作了。

在Java中的`ArrayBlockingQueue`中使用循环的方式解决了假溢出的问题，即**循环队列**。`ArrayBlockingQueue`中存在三个变量，`count`，`takeIndex`，`putIndex`。假设元素数量是n，count记录了当前元素总个数n，putIndex记录了当前存储的数组索引位置，默认是0，每添加一个元素，putIndex加1，当队列满了时，putIndex置为0；takeIndex则存储了出队的索引位置，默认是0，每次出队一个元素，就加1，当takeIndex达到总个数时，重置为0，循环出队。

入队：给定数组，默认从0开始，累加存储；

出队：默认从0开始，累加出队。



![](https://blog.airaccoon.cn/img/bed/20200105/1578205142338.png)



## 链式队列

链式队列比链表在运算实现上更加方便，只在队列的两端操作，是特殊的链表。在队首插入元素，在队尾删除元素。

时间复杂度是$$ O(1) $$ 

