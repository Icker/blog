---
title: MySQL
tags: 关系型数据库
categories: 基础
---



## 一、MySQL体系结构

![image-20190325094318276](https://ws4.sinaimg.cn/large/006tKfTcly1g1esophb9aj30w20u0ag7.jpg)

客户端通过MySQL的连接管理进行身份认证和相关连接处理。认证之后通过SqlInterface统一接收SQL，如果存在缓存，则从缓存中查询对应的数据并返回，如果缓存中没有数据，则通过解析器解析SQL，解析成优化器使用的解析树，通过优化器进行优化，然后调用存储引擎提供的API进行相应数据操作并返回结果。

### 存储引擎
常见的存储引擎是InnoDB、MyISAM、Archive、Memory等等。一般使用InnoDB。

1. Archive：Archive存储引擎通常可以作为日志系统和实时大量数据的采集以及数据备份。
    - 优点：数据占用磁盘空间少。100万的数据量InnoDB占用100M，而Archive只占用了3M。
    - 缺点：
        - 只支持insert和select。不能进行delete和update。
        - 只能为自增ID列建立索引
        - 不支持事务
        - 查询上比innodb慢
2. MyISAM
    - 缺点
        - 只支持表级锁
        - 不支持事务
3. InnoDB
    - 优点
        - 支持事务ACID
        - 支持行级锁
        - 聚集索引（主键索引）的方式存储数据
        - 支持外键关系保证数据完整性（尽量不使用）
        - 多版本并发控制（MVCC）
        - 支持数据缓存

几个存储引擎的对比。
![image-20190325094350099](https://ws2.sinaimg.cn/large/006tKfTcly1g1esp7unjuj30we0hawoz.jpg)

### 查询的整个过程
![image-20190325094426515](https://ws1.sinaimg.cn/large/006tKfTcly1g1espuj3anj314l0u0qp4.jpg)

#### 1. 客户端/服务器通信阶段
##### 通讯方式
“半双工”通讯模式：一请求一响应的通讯模式。A向B放松请求，必须等到B处理并返回了这个请求的结果给A，A才能进行下一次请求。除非A的用户开启了一个新的连接。
##### 连接状态
通过`show processlist`命令可以查看连接状态。
- Sleep：连接中，但没做任何操作。
- Query：正在执行查询。
- Locked：线程正在等待锁的释放
- Sorting Result：线程正在对结果进行排序
- Sending Data：向请求端返回结果

#### 2. 查询缓存
此缓存和mybatis的二级缓存类似，都是将之前查询过的数据保存到缓存中。便于下次查询直接从缓存中提取。只要更新了同一张表的数据，就会把这张表的所有缓存都会清空。      
通过`show variables like 'query_cache%'`查询缓存状态以及缓存的最大处理量等信息
![image-20190325094510895](https://ws4.sinaimg.cn/large/006tKfTcly1g1esqmb6u5j31180eq78f.jpg)
使用`show status like 'QCache'`查询缓存命中使用状态
![image-20190325094525846](https://ws4.sinaimg.cn/large/006tKfTcly1g1esqvorg7j30vo0lwafh.jpg)
问题：

1. 缓存的作用域是？
2. 缓存默认开启还是关闭？
    - 回答：默认关闭。mysql官方不推荐使用

#### 3. 优化器优化
1. in的优化
    - 优化器会使用二分查找。先对in的数据进行排序，然后使用二分法进行查询。查询效率是log（n），比使用or效率高，or是一个一个条件的进行比对。
2. 覆盖索引的扫描
    - 会使用索引而不会查询数据

##### SQL查询优化的指标
访问类型是sql优化当中的极为重要的指标。结果值从好到坏分别是：
system > const > eq_ref > ref > range > index > all

- system：表只有一行记录，基本不会出现。
- const：通过索引一次就找到了，基本用于比较主键和唯一索引。
- eq_ref：唯一索引扫描，对于每个索引键，表中只有一个数据与之匹配。常见于唯一索引和主键扫描。
- ref：非唯一性索引扫描，返回匹配某个单独值的所有行，本质也是一种索引访问
- range：只检索给定范围的行，使用一个索引来选择行
- index：全索引扫描，把索引从头扫描到尾
- all：全表扫描，把表从头扫描到尾

##### 开启慢查询日志
满查询日志默认是关闭的。

```
// 查看慢查询日志是否开启
show variables like 'slow_query%';
// 开启慢查询日志
set global slow_query_log = on;
// 慢查询日志中添加未使用索引的查询
set global log_queries_not_using_indexes = on;
// 设置超过多少时间为慢查询，单位是秒
set global long_query_time = 0.1;

```
## 二、索引
### 索引是什么
索引是什么？        
是为了加速表的行数据检索而创建的分散存储的数据结构。拥有索引的查询，是先查询索引，然后根据索引查询对应的数据。

索引三大优点：
1. 大大减少了数据库的扫描数据量
2. 将随机IO变成顺序IO
3. 帮助数据库避免排序和临时表

> Tips：索引是数据库性能解决方案中的最优解吗？不一定。对于小表而言，全表查询最优。中到大型表，可以使用索引。特大表，建立和使用索引的代价越来越高，使用分片技术更优。

### 索引种类
#### 在索引之前
二分查找的方式，效率提高很多。
1. 二叉查询树
2. 平衡二叉树
  ![image-20190325094605934](https://ws4.sinaimg.cn/large/006tKfTcly1g1esrkvsxtj31in0u0awr.jpg)

平衡二叉树的缺陷还是很明显的：
1. 太深了：因为是逐个节点加载的。数据所处的高度（深度）决定了他的IO次数，IO操作耗时大。
2. 太小了：每一块磁盘块（节点）存储的数据量太小了。比如10的哪一个只存储了数据的磁盘地址。

3. 多路平衡查找树（B-Tree）
  ![image-20190325094628286](https://ws4.sinaimg.cn/large/006tKfTcly1g1esryqs1oj31ni0u07t9.jpg)
  此图的三路只是例子，其实是n路。该B-Tree解决了平衡二叉树的两个问题。
- io操作相对少了
- 每个节点的数据量多了

> Tips：为了维护树的平衡。在进行增删改操作的时候，要对索引进行复杂的调整，这回拖慢整个修改操作性能。因此需要合理的创建索引。

4. 加强版多路平衡查找树（B+Tree）
    - mysql中的B+Tree
      ![image-20190325094655254](https://ws1.sinaimg.cn/large/006tKfTcly1g1essfnmjbj31m80u0b29.jpg)
      n的数值是根据数据的个数决定的。

和B-Tree的区别：
1. B+Tree的搜索采用左闭合区间
2. B+Tree的支节点不保存数据区了，只保存关键字和子节点的引用
3. B+Tree的叶子结点才保存数据
4. B+Tree的叶子结点是顺序排列的，相邻节点具有顺序引用的关系。

B+Tree的优点：
1. B+Tree拥有B-Tree一样的的优势
2. B+Tree的扫库、扫表能力更强
3. 磁盘读写能力更强
4. 排序能力更强
5. 查询效率更加稳定（因为数据区全部在叶子节点，而B-Tree就会时快时慢）

#### B-Tree索引
innodb是以主键为索引组织数据的存储。
![image-20190325094722983](https://ws2.sinaimg.cn/large/006tKfTcly1g1esswvbvwj31ne0u01b7.jpg)
聚集索引（聚簇索引）

根据辅助索引找到主键索引的值，然后根据主键索引进行查询数据。为了保证数据做了迁移，不需要修改辅助索引。这就是设计初衷。
![image-20190325094737890](https://ws1.sinaimg.cn/large/006tKfTcly1g1est61a6wj31xz0u0k5h.jpg)

> Tips：如果没有创建主键。InnoDB系统会自动创建一个隐式的主键，用户不可见。

#### 联合索引
联合索引的前后关系影响很大，选择上要把优先级高的字段放左边。
1. 单列最小空间原则
2. 离散性越高，越适合创建索引
3. 常用列越好

#### 覆盖索引
因为innodb的数据区存放在索引的叶子结点，因此比如创建了name+mobile的联合索引。那么以下语句直接就从节点中返回索引的值而不会再查询到叶子结点对应的数据了。
```
select name, mobile from user where name = 'tom';
```


### 如何创建高性能的索引
#### 什么字段适合创建索引
1. 单列最小空间原则
2. 离散性越高，越适合创建索引
3. 常用列放到最左边（针对联合索引）。最左匹配原则 


### 总结
1. 索引列的数据长度能少则少
2. 索引不是越多越好，越全越好，一定要合适。以空间换时间，同时影响修改的性能。
3. 匹配列前缀不一定会到索引，比如like '555%'（优化器发现字段离散性很好就会使用索引，如果发现离散性不好就不会使用索引）;而like '%555%'和like '%555'不能用到索引。
4. where条件下的not in和<>不能使用索引
5. 匹配范围值，order by可以用到索引（因为B+Tree的数据本身就有排序功能）
6. 多用指定列查询，这样容易命中索引，因为数据区在叶子节点，如果是索引的话就直接返回了，不会查询数据。少用`select *`。
7. 联合索引如果不是按照索引最左列开始查找，无法使用索引。
8. 联合索引精确匹配最左列，范围右边列可以命中索引。
9. 联合索引模糊匹配或者范围匹配最左列，精确匹配右边列，不能使用索引。



## 三、事务
### 什么是事务
数据库操作的最小单元。是一套理论基础。通过锁和MVCC来实现事务的隔离级别。
### 常用场景-P2P购买产品
用户账号金额减少，系统账号增加金额。
```
update user_account set balance = balance - 100 where id = 1;
update system_account set balance = balance + 100 where id = 1;
```

### 事务四大特性（ACID）
原子性、一致性、隔离性、持久性

### 事务的隔离级别
未提交度、已提交读（不可重复读）、可重复读、串型化读

| 事务隔离级别 | 脏读   | 不可重复读 | 幻读                   |
| ------------ | ------ | ---------- | ---------------------- |
| 未提交读     | 存在   | 存在       | 存在                   |
| 已提交读     | 不存在 | 存在       | 存在                   |
| 可重复读     | 不存在 | 不存在     | 存在（Innodb中不存在） |
| 串行化读     | 不存在 | 不存在     | 不存在                 |

在innoDB中的可重复读隔离级别下是通过临键锁（next-key lock）配合MVCC解决了幻读问题。

## 四、锁
### 锁的作用是什么
锁是用于管理不同事务对共享资源的并发访问。
![image-20190325095222181](https://ws3.sinaimg.cn/large/006tKfTcly1g1esy3qjo3j31k60u04qp.jpg)

[InnoDB锁官网介绍](https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html)

### 锁的类型

#### 真实的锁

1. 共享锁（读锁），简称S锁。是行级锁
    - lock in share mode
    - 不同事务对统一数据可以读取，但阻塞写锁。只有释放了读锁，才能够被修改。
2. 排他锁（写锁），简称X锁。是行级锁
    - for update。delete/update/insert语句都会默认加上排他锁。
    - 不共享，一个事务拥有了排他锁，那么其他事务就不能够对该数据进行加锁操作，只有拥有此锁的事务可以对该数据进行读写操作。其他事务只读取该数据的快照。

#### 是否加锁的标识

意向锁是存储引擎自己加的，用户无需干预。意向锁实际上并不是锁，而是一个标识。用来判断是否已经加过锁了，用于提高性能，系统会根据意向锁做判断，如果已经有意向锁，就表示已经加锁或者正在加锁，新的加锁请求就不需要处理了。
1. 意向共享锁（IS）
2. 意向排他锁（IX）
  意义：当事务想要区锁表时，可以先判断意向锁是否存在，如果存在，则快速返回该表不能启动表锁。 



#### 特殊的锁

##### 自增锁

针对自增列自增长的一个特殊的表级锁。        
有一张表，主键自增。当插入数据的事务没有提交或者rollback了，我们再来插入记录，新的纪录的id会空出来一个ID，这就是自增锁的作用。事务没成功ID会永久丢失。可通过命令`show variables like 'innodb_autoinc_lock_mode'`查看自增数，默认是1，代表连续加1。

#### 锁的算法

1. Next-Key Locks（临键锁）：是记录锁和间隙锁的集合
    - 锁住记录+区间（左开右闭）
    - 当sql按照索引进行数据检索时，查询条件范围查询（between and、>、<等），且查询时有数据命中，则此SQL加的锁是next-key lock锁。锁住索引的记录和区间（左开右闭）。
    - next-key lock = gap lock + record lock
    - 是InnoDB默认的行级锁算法
      ![image-20190325095239553](https://ws3.sinaimg.cn/large/006tKfTcly1g1esyei879j31xw0kc131.jpg)

2. Gap Locks（间隙锁）：只针对不存在数据的区间
    - 锁住索引数据不存在的区间（左开右开）
    - 当sql按照索引进行数据检索时，查询条件的数据不存在，这是加上的锁就是gap-lock（间隙锁）。锁住索引不存在的区间（左开右开）。
      ![image-20190325095252576](https://ws3.sinaimg.cn/large/006tKfTcly1g1esymbkq1j31w00u0qm6.jpg)

3. Record Locks（记录锁）
    - 锁住具体的索引项
    - 当sql执行按照唯一性索引进行检索时，查询数据等值匹配且查询的数据存在，则该sql加的锁是记录锁（record lock），锁住具体的索引项。
      ![image-20190325095307854](https://ws3.sinaimg.cn/large/006tKfTcly1g1esywccp7j31uo0kegyu.jpg)

### 锁实际锁了什么？
InnoDB上的行锁实际上是通过给在索引上索引项加上锁来实现的。

只有通过索引条件进行检索，InnoDB才会使用行锁，否则，InnoDB会给整张表的数据进行加表锁，性能极其低下。

表锁：lock tables xxx read/write;

### 锁解决了什么问题
通过上述锁的学习，我们就可以利用锁来解决并发下事务的三大问题：脏读、不可重复读、幻读。

1. 脏读：事务一进行写入操作，相当于加了写锁，事务一就无法获取该数据了，因为写锁是排他的，必须等待事务一释放写锁。（当然，实际情况还是能够读取到数据，只不过读到的是快照数据，是MVCC的解决方案，但这个读取到的不是脏读数据）即解决了脏读问题。
2. 不可重复读：事务一在操作的时候添加读锁，事务二进行写入操作，就必须等待事务一释放锁，即事务一永远都不会读取到修改后的数据，事务一前后读取数据均是修改前的数据，即可重复读了。
3. 幻读：事务一在查询过程中添加了临键锁（next-key lock），事务二进行插入操作，就必须等待间隙锁的释放，否则无法插入。即解决了幻读的问题。

### 死锁的解决方案
1. 事务逻辑按相同顺序操作
2. 大事务分解成小事务
3. 尽量使用索引项进行检索，而不是非索引项。否则将会使用表锁。

## 五、MVCC
针对mysql中的事务，首先用MVCC的理论来解释，一旦发现解释不通，再使用read view这个mysql的具体实现来解释。

MVCC是多版本并发控制。通过保存数据在某个时间点的快照来实现的。mysql中的undo日志就做了这件事。

在innodb中的MVCC并不是真正的MVCC，只是借用了MVCC的名头，实际上是用来解决事务写操作过程中其他事务的读阻塞问题。

脏读和不可重复读不是通过MVCC解决的。

**临键锁（next-key lock）解决当前读的幻读问题。MVCC解决快照读的幻读问题。**

![image-20190325095350938](https://ws1.sinaimg.cn/large/006tKfTcly1g1eszn0wlyj31bg0rgnbx.jpg)

### MVCC重点
数据行版本号<=当前事务版本号        
删除行版本号>当前事务版本号

### 关于read view
以上说的是理论上的MVCC。mysql的实现并不是完全按照这个来的。mysql中有一个read view的变量，是在事务中的第一次select的时候创建的，主要用于保存四个信息：创建时活跃事务最大版本号（up_limit_id）、创建时活跃事务最小版本号（low_limit_id）、自身事务版本号（creator_trx_id）、活跃事务版本号列表（trx_ids）（没有commit和rolback的事务ID）。

不论读事务和写事务谁先开始，只要在写事务提交之后进行的select，就会读取到最新的数据。

会读取当前版本号以下且不在活跃事务版本号列表中的数据

### 当前读和快照读
事务中：
1. 当前读
    - update\delete\insert\select...lock in share mode\select...for update
2. 快照读
    - 普通的select

### 事务日志
事务要保证ACID的完整性必须依靠事务日志做跟踪，每一个操作在真正写入数据数据库之前，先写入到日志文件中。

如要删除一行数据会先在日志文件中将此行标记为删除，但是数据库中的数据文件并没有发生变化。

只有在(包含多个sql语句)整个事务提交后，再把整个事务中的sql语句批量同步到磁盘上的数据库文件。

所有的数据库写操作都会做两件事
1. 写日志
    - 写日志的是操作过程，而不是操作数据本身，速度更快，目的有：回滚（undo log）、保证事务持久性、一致性（redo log）以及主从数据备份（binlog）。
2. 写入数据
    - 随机IO批量同步事务中的SQL数据到磁盘数据库文件中。

#### undo log
##### 是什么
undo日志是为了事务回滚、实现MVCC。
undo log记录了mysql数据的所有的历史版本信息。在事务开启之前，首先会把需要操作的数据被分到undo log中，然后操作数据本身的修改。

mysql的undo log在innodb中实现多版本并发控制：在事务开始之前，将需要操作的数据备份到undolog中，这些undolog中的数据就可以作为数据快照作为其他并发事务的快照读的来源。
![image-20190325095410855](https://ws2.sinaimg.cn/large/006tKfTcly1g1eszzrpwqj31it0u0noh.jpg)

#### redo log
##### 是什么
断电恢复、保证事务的一致性和持久性，数据在物理层面的修改。
##### 事务数据存入顺序
开启事务->操作数据->redo log buffer（写入内存）->file system buffer（写入文件系统缓存）->fsync操作（数据同步到内核缓存中）->redo log file（存储到redo日志文件中）->commit（commit操作就相当于执行数据磁盘的写入操作）。
##### 为什么在事务提交之前要先保存到redo日志中？
因为redo log是顺序读写（redo log是覆盖写入的），而数据库的磁盘写入是随机读写，顺序读写效率远比随机读写要快。

因此，在断电，或者发生故障的情况下，有可能已经写入了redo日志，而没有磁盘写入，在mysql服务重启过程中会读取redo日志进行持久化操作。


![image-20190325095445737](https://ws4.sinaimg.cn/large/006tKfTcly1g1et0l77c8j315i0u04gt.jpg)

![image-20190325095500569](https://ws2.sinaimg.cn/large/006tKfTcly1g1et0uho7tj31v60u04qq.jpg)

![image-20190325095515962](https://ws3.sinaimg.cn/large/006tKfTcly1g1et14glsdj31nt0u0b29.jpg)

[MVCC的参考网站](https://www.cnblogs.com/chenpingzhao/p/5065316.html)
[MVCC参考网站](https://www.jianshu.com/p/b7e740e27b7e)
[MVCC参考网站](https://blog.csdn.net/chen77716/article/details/6742128)

## 六、主从复制





## mysql配置

[http://www.cnblogs.com/wyy123/p/6092976.html](http://www.cnblogs.com/wyy123/p/6092976.html)



## 数据库设计

三大范式。

每一列只有一个单一的值。

1. 第一范式
    - 字段具有原子性，不可再拆分。
2. 第二范式
    - 实体的属性完全依赖于主键。
3. 第三范式
    - 一张表中不可以出现在另一张表中已经存在的非主键字段。（经常性的不实用，为了性能会有冗余字段）



### 规范

#### 表设计规范

1. 单实例表数量必须小于500
2. 单表列数量必须小于30
3. 表必须有主键，例如自增主键

#### 字段设计规范

1. 必须把字段定义为not null并且提供默认值
   1. null的列使得索引/索引统计/值比较 都更加复杂，对于mysql而言难以优化
   2. null对于mysql需要进行特殊处理，增加数据库处理记录的复杂性；同等条件下，表中有较多空字段的时候，数据库的处理性能会降低很多
   3. null需要更多存储空间，无论是表还是索引中每行中的null的列都需要额外的空间进行标志
   4. 对null的处理时，智能采用is null或者is not null，而不能次啊用=、in、<、<>、!=、not in。比如：`where name != '章三';`如果name为null，则查询加过不会抱憾name为null的记录。
2. 禁止使用小数存储货币
   1. 使用整数吧，小数容易导致钱对不上
3. 禁止使用enum，而用tinyint替代。
   1. 增加新的enum值要做ddl操作
   2. enum内部存储就是整数

#### 索引设计规范

1. 单表索引建议控制在5个以内
2. 单索引字段数不允许超过5个
   1. 字段超过5个，实际已经起不到有效过滤数据的作用了。
3. 禁止在更新十分频繁，离散性差的字段上建立索引
   1. 更新会变更B+树，频繁修改降低数据库性能
   2. 离散性差的字段，不能有效过滤数据，和全表搜索没有区别
4. 建立联合索引，离散性高的字段在前面
5. 避免使用select *。有效利用覆盖索引
6. 禁止在where条件上的字段上使用函数或者表达式，这样会导致索引失效
7. 禁止负向查询，以及%开头的模糊查询
   1. 负向查询会导致全表扫描。<>、!=、not、not in、not like等
   2. %开头的模糊查询，会导致全表扫描
8. 禁止大表使用join查询，禁止大表使用子查询
   1. 会产生临时表，消耗较多的内存和CPU资源，影响数据库性能
9. 禁止使用or，尽量使用in
   1. in在mysql中存在优化。
